/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (health stats, reminders, SOS events) and allows controlled access to shared data like appointments. It prioritizes security by default, explicitly denying access unless specifically granted.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores user profiles; acts as the root for user-owned data.
 * - `/users/{userId}/health_stats/{statId}`: Health statistics for each user.
 * - `/users/{userId}/reminders/{reminderId}`: Reminders for each user.
 * - `/users/{userId}/sos_events/{eventId}`: SOS events initiated by the user.
 * - `/doctors/{doctorId}`: Stores doctor profiles.
 * - `/appointments/{appointmentId}`: Stores appointment details; accessible to both the patient and the doctor.
 *
 * Key Security Decisions:
 * - User data is strictly owned and controlled by the user.
 * - Doctors have no special privileges by default; their access to appointment data is determined by their association with a specific appointment.
 * - Listing all users or doctors is explicitly denied to prevent unauthorized data scraping.
 *
 * Denormalization for Authorization:
 * - The rules rely on path-based authorization for user-owned data, eliminating the need for denormalization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @deny (create) User attempts to create a profile with a different ID.
     * @allow (get, list, update, delete) User with matching ID can read, update, and delete their profile.
     * @deny (get, list, update, delete) User attempts to access another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get: if isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to health statistics for a user.
     * @path /users/{userId}/health_stats/{statId}
     * @allow (create) User with matching ID can create health stats.
     * @deny (create) User attempts to create health stats for a different user.
     * @allow (get, list, update, delete) User with matching ID can read, update, and delete their health stats.
     * @deny (get, list, update, delete) User attempts to access another user's health stats.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/health_stats/{statId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to reminders for a user.
     * @path /users/{userId}/reminders/{reminderId}
     * @allow (create) User with matching ID can create reminders.
     * @deny (create) User attempts to create reminders for a different user.
     * @allow (get, list, update, delete) User with matching ID can read, update, and delete their reminders.
     * @deny (get, list, update, delete) User attempts to access another user's reminders.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/reminders/{reminderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to SOS events for a user.
     * @path /users/{userId}/sos_events/{eventId}
     * @allow (create) User with matching ID can create SOS events.
     * @deny (create) User attempts to create SOS events for a different user.
     * @allow (get, list, update, delete) User with matching ID can read, update, and delete their SOS events.
     * @deny (get, list, update, delete) User attempts to access another user's SOS events.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/sos_events/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to doctor profiles.
     * @path /doctors/{doctorId}
     * @allow (create) No one can create doctor profiles directly.
     * @deny (create) All create requests are denied.
     * @allow (get, list) Any signed-in user can read doctor profiles.
     * @deny (update, delete) No one can update or delete doctor profiles directly.
     * @principle Restricts creation, updates and deletions of doctor profiles.
     */
    match /doctors/{doctorId} {
        function isSignedIn() {
            return request.auth != null;
        }

        allow create: if false;
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to appointments.
     * @path /appointments/{appointmentId}
     * @allow (create) A user can create an appointment if they are the patient.
     * @deny (create) A user attempts to create an appointment for another patient.
     * @allow (get, update, delete) The patient or doctor associated with the appointment can access it.
     * @deny (get, update, delete) A user attempts to access an appointment they are not associated with.
     * @principle Restricts access to appointments to the patient and doctor involved.
     */
    match /appointments/{appointmentId} {
      function isSignedIn() {
          return request.auth != null;
      }

      allow create: if isSignedIn() && request.auth.uid == request.resource.data.patientId;
      allow get: if isSignedIn() && (request.auth.uid == resource.data.patientId || get(/databases/$(database)/documents/doctors/$(resource.data.doctorId)).data.userId == request.auth.uid);
      allow list: if isSignedIn() && (request.query.field == 'patientId' && request.query.value == request.auth.uid) || (request.query.field == 'doctorId' && get(/databases/$(database)/documents/doctors/$(request.query.value)).data.userId == request.auth.uid);
      allow update: if isSignedIn() && (request.auth.uid == resource.data.patientId || get(/databases/$(database)/documents/doctors/$(resource.data.doctorId)).data.userId == request.auth.uid) && resource != null;
      allow delete: if isSignedIn() && (request.auth.uid == resource.data.patientId || get(/databases/$(database)/documents/doctors/$(resource.data.doctorId)).data.userId == request.auth.uid) && resource != null;
    }
  }
}